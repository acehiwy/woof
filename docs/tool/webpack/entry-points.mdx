---
sidebar_position: 2000
tags:
  - webpack
---

# Entry Points

An entry point indicates which module webpack should use to <Color color="var(--secondary-font-color)"> begin building </Color> out its internal dependency graph.

Webpack will figure out which other modules and libraries that entry point depends on (directly and indirectly).

&#8203;<Color color="var(--secondary-font-color)"> By default </Color> its value is `./src/index.js`,
but you can specify a different (or multiple) entry points by setting an entry property in the webpack configuration.

For example:

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  entry: "./path/to/my/entry/file.js",
};
```

## Single Entry (Shorthand) Syntax

```typescript
entry: string | [string];
```

<Tabs>
<TabItem value="shorthand" label="Shorthand">

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  entry: "./path/to/my/entry/file.js",
};
```

</TabItem>
<TabItem value="longhand" label="Longhand">

```typescript title=webpack.config.js showLineNumbers
module.exports = {
  entry: {
    main: "./path/to/my/entry/file.js",
  },
};
```

</TabItem>
</Tabs>

We can also pass an array of file paths to the entry property
which creates what is known as a **"multi-main entry"**.

This is useful when you would like to inject multiple dependent files together and graph their dependencies into one "chunk".

<Color color="var(--not-require-but-good-to-know-font-color)">

Single Entry Syntax is a great choice when you are looking to quickly set up a webpack configuration for an application or tool with one entry point (i.e. a library). However, there is not much flexibility in extending or scaling your configuration with this syntax.

</Color>

## Object Syntax

```typescript title=
entry: {
  [entryChunkName: string]: [string] | {}
}
```

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  entry: {
    app: "./src/app.js",
    adminApp: "./src/adminApp.js",
  },
};
```

The object syntax is more verbose. However, this is the most scalable way of defining entry/entries in your application.

<Admonition type="tip" title="later">

**"Scalable webpack configurations"** are ones that can be reused and combined with other partial configurations.
This is a popular technique used to separate concerns by environment, build target, and runtime.

They are then merged using specialized tools like [webpack-merge](https://github.com/survivejs/webpack-merge).

</Admonition>

<Admonition type="note" title="note">

You can pass empty object `{}` to entry when you have only entry points generated by plugins.

</Admonition>

### EntryDescription object

An object of entry point description. You can specify the following properties.

- `dependOn`: The entry points that the current entry point depends on. They <Color color="var(--secondary-font-color)"> must be loaded before this entry point is loaded </Color>.
- `filename`: Specifies the name of each output file on disk.
- `import`: Module(s) that are loaded upon startup.
- `library`: Specify library options to bundle a library from current entry.
- `runtime`: The name of the runtime chunk. When set, a new runtime chunk will be created. It can be set to false to avoid a new runtime chunk since webpack 5.43.0.
- `publicPath`: Specify a public URL address for the output files of this entry when they are referenced in a browser. Also, see [output.publicPath](https://webpack.js.org/configuration/output/#outputpublicpath).

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  entry: {
    a2: "dependingfile.js",
    b2: {
      dependOn: "a2",
      import: "./src/app.js",
    },
  },
};
```

### Caveats

- `runtime` and `dependOn` should not be used together on a single entry.
- `dependOn` must not be circular.
- Make sure `runtime` must not point to an existing entry point name, for example the below config would throw an error:

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  entry: {
    a1: "./a",
    b1: {
      runtime: "a1",
      import: "./b",
    },
  },
};
```

## Use Cases

### Separate App and Vendor Entries

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  entry: {
    // highlight-start
    main: "./src/app.js",
    vendor: "./src/vendor.js",
    // highlight-end
  },
};
```

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  output: {
    filename: "[name].[contenthash].bundle.js",
  },
};
```

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  output: {
    filename: "[name].bundle.js",
  },
};
```

We are telling webpack that we would like 2 separate entry points.

With this, you can <Color color="var(--secondary-font-color)"> import </Color> required <Color color="var(--secondary-font-color)"> libraries or files </Color> that aren't modified (e.g. Bootstrap, jQuery, images, etc) <Color color="var(--secondary-font-color)"> inside </Color> `vendor.js` and <Color color="var(--secondary-font-color)"> they will be bundled together into their own chunk.</Color>

<Color color="var(--not-require-but-good-to-know-font-color)">
  Content hash remains the same, which allows the browser to cache them
  separately thereby reducing load time.
</Color>

### Multi-Page Application

```javascript title=webpack.config.js showLineNumbers
module.exports = {
  entry: {
    pageOne: "./src/pageOne/index.js",
    pageTwo: "./src/pageTwo/index.js",
    pageThree: "./src/pageThree/index.js",
  },
};
```

We are telling webpack that we would like 3 separate dependency graphs.

In a multi-page application, the server is going to fetch a new HTML document for you.
The page reloads this new document and assets are redownloaded.

However, this gives us the unique opportunity to do things like using [optimization.splitChunks](https://webpack.js.org/configuration/optimization/#optimizationsplitchunks) to create bundles of shared application code between each page.

Multi-page applications that reuse a lot of code/modules between entry points can greatly benefit from these techniques, as the number of entry points increases.

<Admonition type="tip" title="later">

As a rule of thumb: Use exactly one entry point for each HTML document.

See the issue [described here](https://bundlers.tooling.report/code-splitting/multi-entry/#webpack) for more details.

</Admonition>

<br />

---

# Sources

- https://webpack.js.org/concepts/entry-points/
